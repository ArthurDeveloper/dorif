#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys

from thrift.transport import TTransport
all_structs = []


class Finger(object):
    """
    Attributes:
     - id
     - ip
     - port
     - name
    """


    def __init__(self, id=None, ip=None, port=None, name=None,):
        self.id = id
        self.ip = ip
        self.port = port
        self.name = name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.ip = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Finger')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I64, 1)
            oprot.writeI64(self.id)
            oprot.writeFieldEnd()
        if self.ip is not None:
            oprot.writeFieldBegin('ip', TType.STRING, 2)
            oprot.writeString(self.ip.encode('utf-8') if sys.version_info[0] == 2 else self.ip)
            oprot.writeFieldEnd()
        if self.port is not None:
            oprot.writeFieldBegin('port', TType.I32, 3)
            oprot.writeI32(self.port)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 4)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class FingerTable(object):
    """
    Attributes:
     - fingers
     - successorList
    """


    def __init__(self, fingers=None, successorList=None,):
        self.fingers = fingers
        self.successorList = successorList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.fingers = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = Finger()
                        _elem5.read(iprot)
                        self.fingers.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.successorList = []
                    (_etype9, _size6) = iprot.readListBegin()
                    for _i10 in range(_size6):
                        _elem11 = Finger()
                        _elem11.read(iprot)
                        self.successorList.append(_elem11)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('FingerTable')
        if self.fingers is not None:
            oprot.writeFieldBegin('fingers', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.fingers))
            for iter12 in self.fingers:
                iter12.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.successorList is not None:
            oprot.writeFieldBegin('successorList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.successorList))
            for iter13 in self.successorList:
                iter13.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Node(object):
    """
    Attributes:
     - id
     - numBits
     - fingerTable
     - predecessor
     - ip
     - port
     - name
    """


    def __init__(self, id=None, numBits=None, fingerTable=None, predecessor=None, ip=None, port=None, name=None,):
        self.id = id
        self.numBits = numBits
        self.fingerTable = fingerTable
        self.predecessor = predecessor
        self.ip = ip
        self.port = port
        self.name = name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.numBits = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.fingerTable = FingerTable()
                    self.fingerTable.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.predecessor = Finger()
                    self.predecessor.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.ip = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Node')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I64, 1)
            oprot.writeI64(self.id)
            oprot.writeFieldEnd()
        if self.numBits is not None:
            oprot.writeFieldBegin('numBits', TType.I32, 2)
            oprot.writeI32(self.numBits)
            oprot.writeFieldEnd()
        if self.fingerTable is not None:
            oprot.writeFieldBegin('fingerTable', TType.STRUCT, 3)
            self.fingerTable.write(oprot)
            oprot.writeFieldEnd()
        if self.predecessor is not None:
            oprot.writeFieldBegin('predecessor', TType.STRUCT, 4)
            self.predecessor.write(oprot)
            oprot.writeFieldEnd()
        if self.ip is not None:
            oprot.writeFieldBegin('ip', TType.STRING, 5)
            oprot.writeString(self.ip.encode('utf-8') if sys.version_info[0] == 2 else self.ip)
            oprot.writeFieldEnd()
        if self.port is not None:
            oprot.writeFieldBegin('port', TType.I32, 6)
            oprot.writeI32(self.port)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 7)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class UnableToJoinChordException(TException):
    """
    Attributes:
     - errNum
     - errMsg
    """


    def __init__(self, errNum=0, errMsg="An error occurred and the node was unable to join the Chord.",):
        self.errNum = errNum
        self.errMsg = errMsg

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.errNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.errMsg = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('UnableToJoinChordException')
        if self.errNum is not None:
            oprot.writeFieldBegin('errNum', TType.I32, 1)
            oprot.writeI32(self.errNum)
            oprot.writeFieldEnd()
        if self.errMsg is not None:
            oprot.writeFieldBegin('errMsg', TType.STRING, 2)
            oprot.writeString(self.errMsg.encode('utf-8') if sys.version_info[0] == 2 else self.errMsg)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class UnableToFindSuccessorException(TException):
    """
    Attributes:
     - errNum
     - errMsg
    """


    def __init__(self, errNum=1, errMsg="An error occurred and the node was unable to find the key's successor.",):
        self.errNum = errNum
        self.errMsg = errMsg

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.errNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.errMsg = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('UnableToFindSuccessorException')
        if self.errNum is not None:
            oprot.writeFieldBegin('errNum', TType.I32, 1)
            oprot.writeI32(self.errNum)
            oprot.writeFieldEnd()
        if self.errMsg is not None:
            oprot.writeFieldBegin('errMsg', TType.STRING, 2)
            oprot.writeString(self.errMsg.encode('utf-8') if sys.version_info[0] == 2 else self.errMsg)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class UnableToFindPredecessorException(TException):
    """
    Attributes:
     - errNum
     - errMsg
    """


    def __init__(self, errNum=2, errMsg="An error occurred and the node was unable to find the key's predecessor.",):
        self.errNum = errNum
        self.errMsg = errMsg

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.errNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.errMsg = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('UnableToFindPredecessorException')
        if self.errNum is not None:
            oprot.writeFieldBegin('errNum', TType.I32, 1)
            oprot.writeI32(self.errNum)
            oprot.writeFieldEnd()
        if self.errMsg is not None:
            oprot.writeFieldBegin('errMsg', TType.STRING, 2)
            oprot.writeString(self.errMsg.encode('utf-8') if sys.version_info[0] == 2 else self.errMsg)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class UnableToFindClosestPrecedingFingerException(TException):
    """
    Attributes:
     - errNum
     - errMsg
    """


    def __init__(self, errNum=3, errMsg="An error occurred and the node was unable to find the closest preceding finger.",):
        self.errNum = errNum
        self.errMsg = errMsg

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.errNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.errMsg = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('UnableToFindClosestPrecedingFingerException')
        if self.errNum is not None:
            oprot.writeFieldBegin('errNum', TType.I32, 1)
            oprot.writeI32(self.errNum)
            oprot.writeFieldEnd()
        if self.errMsg is not None:
            oprot.writeFieldBegin('errMsg', TType.STRING, 2)
            oprot.writeString(self.errMsg.encode('utf-8') if sys.version_info[0] == 2 else self.errMsg)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class UnableToTransferKeysException(TException):
    """
    Attributes:
     - errNum
     - errMsg
    """


    def __init__(self, errNum=4, errMsg="An error occurred and the node was unable to transfer it's keys.",):
        self.errNum = errNum
        self.errMsg = errMsg

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.errNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.errMsg = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('UnableToTransferKeysException')
        if self.errNum is not None:
            oprot.writeFieldBegin('errNum', TType.I32, 1)
            oprot.writeI32(self.errNum)
            oprot.writeFieldEnd()
        if self.errMsg is not None:
            oprot.writeFieldBegin('errMsg', TType.STRING, 2)
            oprot.writeString(self.errMsg.encode('utf-8') if sys.version_info[0] == 2 else self.errMsg)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class UnableToStabilizeException(TException):
    """
    Attributes:
     - errNum
     - errMsg
    """


    def __init__(self, errNum=5, errMsg="An error occurred while executing stabilization protocol.",):
        self.errNum = errNum
        self.errMsg = errMsg

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.errNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.errMsg = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('UnableToStabilizeException')
        if self.errNum is not None:
            oprot.writeFieldBegin('errNum', TType.I32, 1)
            oprot.writeI32(self.errNum)
            oprot.writeFieldEnd()
        if self.errMsg is not None:
            oprot.writeFieldBegin('errMsg', TType.STRING, 2)
            oprot.writeString(self.errMsg.encode('utf-8') if sys.version_info[0] == 2 else self.errMsg)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class UnableToNotifyException(TException):
    """
    Attributes:
     - errNum
     - errMsg
    """


    def __init__(self, errNum=6, errMsg="The node was unable send a notification to other node.",):
        self.errNum = errNum
        self.errMsg = errMsg

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.errNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.errMsg = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('UnableToNotifyException')
        if self.errNum is not None:
            oprot.writeFieldBegin('errNum', TType.I32, 1)
            oprot.writeI32(self.errNum)
            oprot.writeFieldEnd()
        if self.errMsg is not None:
            oprot.writeFieldBegin('errMsg', TType.STRING, 2)
            oprot.writeString(self.errMsg.encode('utf-8') if sys.version_info[0] == 2 else self.errMsg)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class UnableToFixFingerException(TException):
    """
    Attributes:
     - errNum
     - errMsg
    """


    def __init__(self, errNum=7, errMsg="An error occurred while refreshing the finger table.",):
        self.errNum = errNum
        self.errMsg = errMsg

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.errNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.errMsg = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('UnableToFixFingerException')
        if self.errNum is not None:
            oprot.writeFieldBegin('errNum', TType.I32, 1)
            oprot.writeI32(self.errNum)
            oprot.writeFieldEnd()
        if self.errMsg is not None:
            oprot.writeFieldBegin('errMsg', TType.STRING, 2)
            oprot.writeString(self.errMsg.encode('utf-8') if sys.version_info[0] == 2 else self.errMsg)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class UnableToSendSelfException(TException):
    """
    Attributes:
     - errNum
     - errMsg
    """


    def __init__(self, errNum=8, errMsg="The node was unable to send its data.",):
        self.errNum = errNum
        self.errMsg = errMsg

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.errNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.errMsg = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('UnableToSendSelfException')
        if self.errNum is not None:
            oprot.writeFieldBegin('errNum', TType.I32, 1)
            oprot.writeI32(self.errNum)
            oprot.writeFieldEnd()
        if self.errMsg is not None:
            oprot.writeFieldBegin('errMsg', TType.STRING, 2)
            oprot.writeString(self.errMsg.encode('utf-8') if sys.version_info[0] == 2 else self.errMsg)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class UnableToSetPredecessorException(TException):
    """
    Attributes:
     - errNum
     - errMsg
    """


    def __init__(self, errNum=9, errMsg="The node was unable to set its predecessor.",):
        self.errNum = errNum
        self.errMsg = errMsg

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.errNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.errMsg = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('UnableToSetPredecessorException')
        if self.errNum is not None:
            oprot.writeFieldBegin('errNum', TType.I32, 1)
            oprot.writeI32(self.errNum)
            oprot.writeFieldEnd()
        if self.errMsg is not None:
            oprot.writeFieldBegin('errMsg', TType.STRING, 2)
            oprot.writeString(self.errMsg.encode('utf-8') if sys.version_info[0] == 2 else self.errMsg)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(Finger)
Finger.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'id', None, None, ),  # 1
    (2, TType.STRING, 'ip', 'UTF8', None, ),  # 2
    (3, TType.I32, 'port', None, None, ),  # 3
    (4, TType.STRING, 'name', 'UTF8', None, ),  # 4
)
all_structs.append(FingerTable)
FingerTable.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'fingers', (TType.STRUCT, [Finger, None], False), None, ),  # 1
    (2, TType.LIST, 'successorList', (TType.STRUCT, [Finger, None], False), None, ),  # 2
)
all_structs.append(Node)
Node.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'id', None, None, ),  # 1
    (2, TType.I32, 'numBits', None, None, ),  # 2
    (3, TType.STRUCT, 'fingerTable', [FingerTable, None], None, ),  # 3
    (4, TType.STRUCT, 'predecessor', [Finger, None], None, ),  # 4
    (5, TType.STRING, 'ip', 'UTF8', None, ),  # 5
    (6, TType.I32, 'port', None, None, ),  # 6
    (7, TType.STRING, 'name', 'UTF8', None, ),  # 7
)
all_structs.append(UnableToJoinChordException)
UnableToJoinChordException.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'errNum', None, 0, ),  # 1
    (2, TType.STRING, 'errMsg', 'UTF8', "An error occurred and the node was unable to join the Chord.", ),  # 2
)
all_structs.append(UnableToFindSuccessorException)
UnableToFindSuccessorException.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'errNum', None, 1, ),  # 1
    (2, TType.STRING, 'errMsg', 'UTF8', "An error occurred and the node was unable to find the key's successor.", ),  # 2
)
all_structs.append(UnableToFindPredecessorException)
UnableToFindPredecessorException.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'errNum', None, 2, ),  # 1
    (2, TType.STRING, 'errMsg', 'UTF8', "An error occurred and the node was unable to find the key's predecessor.", ),  # 2
)
all_structs.append(UnableToFindClosestPrecedingFingerException)
UnableToFindClosestPrecedingFingerException.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'errNum', None, 3, ),  # 1
    (2, TType.STRING, 'errMsg', 'UTF8', "An error occurred and the node was unable to find the closest preceding finger.", ),  # 2
)
all_structs.append(UnableToTransferKeysException)
UnableToTransferKeysException.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'errNum', None, 4, ),  # 1
    (2, TType.STRING, 'errMsg', 'UTF8', "An error occurred and the node was unable to transfer it's keys.", ),  # 2
)
all_structs.append(UnableToStabilizeException)
UnableToStabilizeException.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'errNum', None, 5, ),  # 1
    (2, TType.STRING, 'errMsg', 'UTF8', "An error occurred while executing stabilization protocol.", ),  # 2
)
all_structs.append(UnableToNotifyException)
UnableToNotifyException.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'errNum', None, 6, ),  # 1
    (2, TType.STRING, 'errMsg', 'UTF8', "The node was unable send a notification to other node.", ),  # 2
)
all_structs.append(UnableToFixFingerException)
UnableToFixFingerException.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'errNum', None, 7, ),  # 1
    (2, TType.STRING, 'errMsg', 'UTF8', "An error occurred while refreshing the finger table.", ),  # 2
)
all_structs.append(UnableToSendSelfException)
UnableToSendSelfException.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'errNum', None, 8, ),  # 1
    (2, TType.STRING, 'errMsg', 'UTF8', "The node was unable to send its data.", ),  # 2
)
all_structs.append(UnableToSetPredecessorException)
UnableToSetPredecessorException.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'errNum', None, 9, ),  # 1
    (2, TType.STRING, 'errMsg', 'UTF8', "The node was unable to set its predecessor.", ),  # 2
)
fix_spec(all_structs)
del all_structs
